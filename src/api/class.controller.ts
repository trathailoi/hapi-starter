import { Request, ResponseToolkit } from '@hapi/hapi'
import { inject, injectable } from 'inversify'
import { TYPES } from '../ioc/types'
import { Logger } from 'winston'
import { HapiRoute } from '../decorators/decorators'
import { HapiController } from './hapi-controller'
import * as Joi from '@hapi/joi'
import * as Boom from '@hapi/boom'
import { Mapper } from '../helpers/mapper'
import { IClassController } from './interfaces/class.interface'

import { ClassService } from '../service/class.service'
import { ClassModel } from '../dto/class'
import { Class } from '../entity/class'

/**
 * This file is automatically generated by swagger.  This is a stub.  It is expected that developers will fill in the logic
 * for each method - as generated each endpoint will return a 501 - not implemented.
 *
 * IT IS NOT SAFE TO OVERWRITE AN EXISTING FILE WITH THIS ONE.
 *
 * If there are changes to the swagger that describes routes implemented in this controller, the related interface will
 * change and the TypeScript compiler will complain that the controller does not implement the interface correctly.  In
 * this case, you can find the missing (added) method(s) in the generated controller and copy the stubs to your implementation.
 */
@injectable()
class ClassController extends HapiController implements IClassController {

  /**
   * Here we are also injecting the car service to manage interactions with the database
   * in addition to the logger and mapper.  You can inject as many dependencies as you need.
   *
   * This is a test.
   */
  constructor(
      @inject(TYPES.Logger) private logger: Logger,
      @inject(TYPES.ClassService) private service: ClassService,
      @inject(TYPES.Mapper) private mapper: Mapper)
  {
      super()
      this.logger.info('Created controller ClassController')
  }

// #region addClass
/**
 * Add a new class to the system
 */
  @HapiRoute({
    method: 'POST',
    path: 'classes',
    options: {
      validate: {
        payload: {
          name: Joi.string().required()
        }
      },
      description: 'Add a new class to the system',
      tags: ['class'],
      auth: false
    }
  })
  public async addClass(request: Request, toolkit: ResponseToolkit) {
    const payload: Class = this.mapper.map(ClassModel, Class, request.payload)
    const _class = await this.service.save(payload)
    return toolkit.response({id: _class!.id}).code(201)
  }
// #endregion

// #region findClasses
/**
 * Finds all the classes
 */
  @HapiRoute({
    method: 'GET',
    path: 'classes',
    options: {
      validate: { },
      description: 'Finds Classes',
      tags: ['class'],
      auth: false
    }
  })
  public async findClasses(request: Request, toolkit: ResponseToolkit) {
    const _classes = await this.service.findAll()
    return toolkit.response(_classes)
  }
// #endregion

// #region getClassById
/**
 * Returns a single class
 */
  @HapiRoute({
    method: 'GET',
    path: 'classes/{id}',
    options: {
      validate: {
        params: {
          id: Joi.string().guid().length(36).required()
        }
      },
      description: 'Find class by ID',
      tags: ['class'],
      auth: false
    }
  })
  public async getClassById(request: Request, toolkit: ResponseToolkit) {
    const item = await this.service.findById(request.params.id)
    if (!item) {
      throw Boom.notFound()
    }
    return toolkit.response(item)
  }
// #endregion

// #region updateClass
/**
 * Updates an existing class by ID
 */
  @HapiRoute({
    method: 'PATCH',
    path: 'classes/{id}',
    options: {
      validate: {
        params: {
          id: Joi.string().guid().length(36).required()
        },
        payload: {
          name: Joi.string().required()
        }
      },
      description: 'Updates an existing class by ID',
      tags: ['class'],
      auth: false
    }
  })
  public async updateClass(request: Request, toolkit: ResponseToolkit) {
    const payload: Class = this.mapper.map(ClassModel, Class, Object.assign({}, request.payload, request.params))

    const item = await this.service.findById(payload.id)
    if (!item) {
      throw Boom.notFound()
    }
    await this.service.save(payload)
    return toolkit.response().code(204)
  }
// #endregion

// #region deleteClass
/**
 * Deletes a class by ID
 */
  @HapiRoute({
    method: 'DELETE',
    path: 'classes/{id}',
    options: {
      validate: {
        params: {
          id: Joi.string().guid().length(36).required()
        }
      },
      description: 'Deletes a class by ID',
      tags: ['class'],
      auth: false
    }
  })
  public async deleteClass(request: Request, toolkit: ResponseToolkit) {
    const result = await this.service.delete(request.params.id)
    if (!result.affected) {
      throw Boom.notFound()
    }
    return toolkit.response().code(204)
  }
// #endregion

}

export { ClassController }
